// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.20.0
// source: vnet.proto

package netd_v1alpha

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// NetworkDClient is the client API for NetworkD service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NetworkDClient interface {
	// VNet crud API
	CreateVNet(ctx context.Context, in *CreateVNetRequest, opts ...grpc.CallOption) (*VNet, error)
	ListVNets(ctx context.Context, in *ListVNetsRequest, opts ...grpc.CallOption) (*VNets, error)
	GetVNet(ctx context.Context, in *GetVNetRequest, opts ...grpc.CallOption) (*VNet, error)
	DeleteVNet(ctx context.Context, in *DeleteVNetRequest, opts ...grpc.CallOption) (*Empty, error)
	WatchVNets(ctx context.Context, in *WatchVNetsRequest, opts ...grpc.CallOption) (NetworkD_WatchVNetsClient, error)
	// Allocates an IP and publishes the Nic configuration in the vnet.
	AllocateIp(ctx context.Context, in *AllocateIpRequest, opts ...grpc.CallOption) (*AllocateIpResponse, error)
	// Deallocates an IP and publishes the Nic configuration removal in the vnet.
	DeallocateIp(ctx context.Context, in *DeallocateIpRequest, opts ...grpc.CallOption) (*DeallocateIpResponse, error)
	// Watch for changes on IP/endpoints in the vnet.
	WatchIPMapping(ctx context.Context, in *WatchIPMappingRequest, opts ...grpc.CallOption) (NetworkD_WatchIPMappingClient, error)
}

type networkDClient struct {
	cc grpc.ClientConnInterface
}

func NewNetworkDClient(cc grpc.ClientConnInterface) NetworkDClient {
	return &networkDClient{cc}
}

func (c *networkDClient) CreateVNet(ctx context.Context, in *CreateVNetRequest, opts ...grpc.CallOption) (*VNet, error) {
	out := new(VNet)
	err := c.cc.Invoke(ctx, "/vnet.v1alpha.NetworkD/CreateVNet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkDClient) ListVNets(ctx context.Context, in *ListVNetsRequest, opts ...grpc.CallOption) (*VNets, error) {
	out := new(VNets)
	err := c.cc.Invoke(ctx, "/vnet.v1alpha.NetworkD/ListVNets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkDClient) GetVNet(ctx context.Context, in *GetVNetRequest, opts ...grpc.CallOption) (*VNet, error) {
	out := new(VNet)
	err := c.cc.Invoke(ctx, "/vnet.v1alpha.NetworkD/GetVNet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkDClient) DeleteVNet(ctx context.Context, in *DeleteVNetRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/vnet.v1alpha.NetworkD/DeleteVNet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkDClient) WatchVNets(ctx context.Context, in *WatchVNetsRequest, opts ...grpc.CallOption) (NetworkD_WatchVNetsClient, error) {
	stream, err := c.cc.NewStream(ctx, &NetworkD_ServiceDesc.Streams[0], "/vnet.v1alpha.NetworkD/WatchVNets", opts...)
	if err != nil {
		return nil, err
	}
	x := &networkDWatchVNetsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NetworkD_WatchVNetsClient interface {
	Recv() (*WatchVNetsResponse, error)
	grpc.ClientStream
}

type networkDWatchVNetsClient struct {
	grpc.ClientStream
}

func (x *networkDWatchVNetsClient) Recv() (*WatchVNetsResponse, error) {
	m := new(WatchVNetsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *networkDClient) AllocateIp(ctx context.Context, in *AllocateIpRequest, opts ...grpc.CallOption) (*AllocateIpResponse, error) {
	out := new(AllocateIpResponse)
	err := c.cc.Invoke(ctx, "/vnet.v1alpha.NetworkD/AllocateIp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkDClient) DeallocateIp(ctx context.Context, in *DeallocateIpRequest, opts ...grpc.CallOption) (*DeallocateIpResponse, error) {
	out := new(DeallocateIpResponse)
	err := c.cc.Invoke(ctx, "/vnet.v1alpha.NetworkD/DeallocateIp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkDClient) WatchIPMapping(ctx context.Context, in *WatchIPMappingRequest, opts ...grpc.CallOption) (NetworkD_WatchIPMappingClient, error) {
	stream, err := c.cc.NewStream(ctx, &NetworkD_ServiceDesc.Streams[1], "/vnet.v1alpha.NetworkD/WatchIPMapping", opts...)
	if err != nil {
		return nil, err
	}
	x := &networkDWatchIPMappingClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NetworkD_WatchIPMappingClient interface {
	Recv() (*WatchIPMappingResponse, error)
	grpc.ClientStream
}

type networkDWatchIPMappingClient struct {
	grpc.ClientStream
}

func (x *networkDWatchIPMappingClient) Recv() (*WatchIPMappingResponse, error) {
	m := new(WatchIPMappingResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NetworkDServer is the server API for NetworkD service.
// All implementations must embed UnimplementedNetworkDServer
// for forward compatibility
type NetworkDServer interface {
	// VNet crud API
	CreateVNet(context.Context, *CreateVNetRequest) (*VNet, error)
	ListVNets(context.Context, *ListVNetsRequest) (*VNets, error)
	GetVNet(context.Context, *GetVNetRequest) (*VNet, error)
	DeleteVNet(context.Context, *DeleteVNetRequest) (*Empty, error)
	WatchVNets(*WatchVNetsRequest, NetworkD_WatchVNetsServer) error
	// Allocates an IP and publishes the Nic configuration in the vnet.
	AllocateIp(context.Context, *AllocateIpRequest) (*AllocateIpResponse, error)
	// Deallocates an IP and publishes the Nic configuration removal in the vnet.
	DeallocateIp(context.Context, *DeallocateIpRequest) (*DeallocateIpResponse, error)
	// Watch for changes on IP/endpoints in the vnet.
	WatchIPMapping(*WatchIPMappingRequest, NetworkD_WatchIPMappingServer) error
	mustEmbedUnimplementedNetworkDServer()
}

// UnimplementedNetworkDServer must be embedded to have forward compatible implementations.
type UnimplementedNetworkDServer struct {
}

func (UnimplementedNetworkDServer) CreateVNet(context.Context, *CreateVNetRequest) (*VNet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVNet not implemented")
}
func (UnimplementedNetworkDServer) ListVNets(context.Context, *ListVNetsRequest) (*VNets, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListVNets not implemented")
}
func (UnimplementedNetworkDServer) GetVNet(context.Context, *GetVNetRequest) (*VNet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVNet not implemented")
}
func (UnimplementedNetworkDServer) DeleteVNet(context.Context, *DeleteVNetRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteVNet not implemented")
}
func (UnimplementedNetworkDServer) WatchVNets(*WatchVNetsRequest, NetworkD_WatchVNetsServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchVNets not implemented")
}
func (UnimplementedNetworkDServer) AllocateIp(context.Context, *AllocateIpRequest) (*AllocateIpResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllocateIp not implemented")
}
func (UnimplementedNetworkDServer) DeallocateIp(context.Context, *DeallocateIpRequest) (*DeallocateIpResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeallocateIp not implemented")
}
func (UnimplementedNetworkDServer) WatchIPMapping(*WatchIPMappingRequest, NetworkD_WatchIPMappingServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchIPMapping not implemented")
}
func (UnimplementedNetworkDServer) mustEmbedUnimplementedNetworkDServer() {}

// UnsafeNetworkDServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NetworkDServer will
// result in compilation errors.
type UnsafeNetworkDServer interface {
	mustEmbedUnimplementedNetworkDServer()
}

func RegisterNetworkDServer(s grpc.ServiceRegistrar, srv NetworkDServer) {
	s.RegisterService(&NetworkD_ServiceDesc, srv)
}

func _NetworkD_CreateVNet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVNetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkDServer).CreateVNet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vnet.v1alpha.NetworkD/CreateVNet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkDServer).CreateVNet(ctx, req.(*CreateVNetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkD_ListVNets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVNetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkDServer).ListVNets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vnet.v1alpha.NetworkD/ListVNets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkDServer).ListVNets(ctx, req.(*ListVNetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkD_GetVNet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVNetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkDServer).GetVNet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vnet.v1alpha.NetworkD/GetVNet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkDServer).GetVNet(ctx, req.(*GetVNetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkD_DeleteVNet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVNetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkDServer).DeleteVNet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vnet.v1alpha.NetworkD/DeleteVNet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkDServer).DeleteVNet(ctx, req.(*DeleteVNetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkD_WatchVNets_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchVNetsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetworkDServer).WatchVNets(m, &networkDWatchVNetsServer{stream})
}

type NetworkD_WatchVNetsServer interface {
	Send(*WatchVNetsResponse) error
	grpc.ServerStream
}

type networkDWatchVNetsServer struct {
	grpc.ServerStream
}

func (x *networkDWatchVNetsServer) Send(m *WatchVNetsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _NetworkD_AllocateIp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllocateIpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkDServer).AllocateIp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vnet.v1alpha.NetworkD/AllocateIp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkDServer).AllocateIp(ctx, req.(*AllocateIpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkD_DeallocateIp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeallocateIpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkDServer).DeallocateIp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vnet.v1alpha.NetworkD/DeallocateIp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkDServer).DeallocateIp(ctx, req.(*DeallocateIpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkD_WatchIPMapping_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchIPMappingRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NetworkDServer).WatchIPMapping(m, &networkDWatchIPMappingServer{stream})
}

type NetworkD_WatchIPMappingServer interface {
	Send(*WatchIPMappingResponse) error
	grpc.ServerStream
}

type networkDWatchIPMappingServer struct {
	grpc.ServerStream
}

func (x *networkDWatchIPMappingServer) Send(m *WatchIPMappingResponse) error {
	return x.ServerStream.SendMsg(m)
}

// NetworkD_ServiceDesc is the grpc.ServiceDesc for NetworkD service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NetworkD_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "vnet.v1alpha.NetworkD",
	HandlerType: (*NetworkDServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVNet",
			Handler:    _NetworkD_CreateVNet_Handler,
		},
		{
			MethodName: "ListVNets",
			Handler:    _NetworkD_ListVNets_Handler,
		},
		{
			MethodName: "GetVNet",
			Handler:    _NetworkD_GetVNet_Handler,
		},
		{
			MethodName: "DeleteVNet",
			Handler:    _NetworkD_DeleteVNet_Handler,
		},
		{
			MethodName: "AllocateIp",
			Handler:    _NetworkD_AllocateIp_Handler,
		},
		{
			MethodName: "DeallocateIp",
			Handler:    _NetworkD_DeallocateIp_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchVNets",
			Handler:       _NetworkD_WatchVNets_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchIPMapping",
			Handler:       _NetworkD_WatchIPMapping_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "vnet.proto",
}
